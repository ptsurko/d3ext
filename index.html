
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/2.3.2/css/bootstrap.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/multibrush.css"/>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.3.9/d3.js"></script>
    <script src="http://mbostock.github.io/d3/talk/20111116/d3/d3.csv.js"></script>
    <script src="js/multibrush.js"></script>
  </head>
  <body>
    <div class="multibrushXYSample"></div>
    <div class="multibrushXSample"></div>
    <div class="multibrushYSample"></div>

    <script type="text/javascript">
(function() {
  var width = 700,
    height = 400,
    defaultExtent = [[100, 100], [300, 300]],
    data = d3.range(2000).map(function() { return [Math.random() * width, Math.random() * width]; });

var quadtree = d3.geom.quadtree()
    .extent([[-1, -1], [width + 1, height + 1]])
    (data);

var x = d3.scale.identity().domain([0, width]),
    y = d3.scale.identity().domain([0, height]);

var brush = d3.svg.multiBrush()
    .x(x)
    .y(y)
    .extent([[[100,100], [300,300]]])
    .on("brush", brushed);

var svg = d3.select(".multibrushXYSample").append("svg")
    .attr("width", width)
    .attr("height", height);

var point = svg.selectAll(".point")
    .data(data)
  .enter().append("circle")
    .attr("class", "point")
    .attr("cx", function(d) { return d[0]; })
    .attr("cy", function(d) { return d[1]; })
    .attr("r", 4);

svg.append("g")
    .attr("class", "brush")
    .call(brush);
    //.call(brush.event);

function brushed() {
  var extents = brush.extent();
  point.each(function(d) { d.selected = false; });
  extents.forEach(function(extent) {
    search(quadtree, extent[0][0], extent[0][1], extent[1][0], extent[1][1]);
  });
  point.classed("selected", function(d) { return d.selected; });
}

// Find the nodes within the specified rectangle.
function search(quadtree, x0, y0, x3, y3) {
  quadtree.visit(function(node, x1, y1, x2, y2) {
    var p = node.point;
    if (p) p.selected = p.selected || ((p[0] >= x0) && (p[0] < x3) && (p[1] >= y0) && (p[1] < y3));
    return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
  });
}

}());
    </script>
    <script type="text/javascript">
(function() {
  var dataset = [];

  for(var i = 0; i < 500; i++) {
    dataset.push([Math.floor((Math.random()*500)+1),Math.floor((Math.random()*500)+1)]);
  }

  var m = [50, 50, 50, 50],
      w = 800 - m[1] - m[3],
      h = 500 - m[0] - m[2];

  var xScale = d3.scale.linear()
      .domain([0, d3.max(dataset, function(d) {
        return d[0];
      })])
      .range([0, w]),
    yScale = d3.scale.linear()
      .domain([0, d3.max(dataset, function(d) {
        return d[1];
      })])
      .range([h, 0]);
    xScale.brush = d3.svg.multiBrush()
          .x(xScale)
          .extent([[50, 200], [300, 500]])
          .on("brush", brush);

  var xAxis = d3.svg.axis()
      .scale(xScale)
      .orient("bottom"),
      yAxis = d3.svg.axis()
      .scale(yScale)
      .orient("left");

  var svg = d3.select(".multibrushXSample").append("svg:svg")
      .attr("width", w + m[1] + m[3])
      .attr("height", h + m[0] + m[2])
      .append("svg:g")
        .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

  var foreground = svg.selectAll("circle")
      .data(dataset)
      .enter()
      .append("circle")
      .attr("cx", function(d) {
        return xScale(d[0]);
      })
      .attr("cy", function(d) {
        return yScale(d[1]);
      })
      .attr("r", 2);

  // Add an axis and title.
  svg.append("svg:g")
      .attr("class", "axis")
      .attr("transform", "translate(" + 0 + "," + h + ")")
      .call(xAxis)
      .append("svg:g")
        .attr("class", "brush")
        .call(xScale.brush)
        .selectAll("rect")
          .attr("y", -8)
          .attr("height", 16);

  svg.append("svg:g")
      .attr("class", "axis")
      .call(yAxis);

  function brush() {
    var extents = xScale.brush.extent();
        
    foreground.classed("multibrush-dot-fade", function(d) {
        var res = false;
        for(var j = 0; j < extents.length; j++) {
          res = res || extents[j][0] <= d[0] && d[0] <= extents[j][1];
        }
        return !res;
      });
  }
}());
    </script>

    <script type="text/javascript">
(function() {
  var species = ["setosa", "versicolor", "virginica"],
      traits = ["sepal length", "petal length", "sepal width", "petal width"];

  var m = [50, 50, 50, 50],
      w = 800 - m[1] - m[3],
      h = 500 - m[0] - m[2];

  var x = d3.scale.ordinal().domain(traits).rangePoints([0, w]),
      y = {};

  var line = d3.svg.line(),
      axis = d3.svg.axis().orient("left"),
      foreground;

  var svg = d3.select(".multibrushYSample").append("svg:svg")
      .attr("width", w + m[1] + m[3])
      .attr("height", h + m[0] + m[2])
      .append("svg:g")
        .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

  d3.csv("iris.csv", function(flowers) {

    // Create a scale and brush for each trait.
    traits.forEach(function(d) {
      // Coerce values to numbers.
      flowers.forEach(function(p) { p[d] = +p[d]; });

      y[d] = d3.scale.linear()
          .domain(d3.extent(flowers, function(p) { return p[d]; }))
          .range([h, 0]);

      y[d].brush = d3.svg.multiBrush()
          .y(y[d])
          .on("brush", brush);
    });

    // Add a legend.
    var legend = svg.selectAll("g.legend")
        .data(species)
      .enter().append("svg:g")
        .attr("class", "legend")
        .attr("transform", function(d, i) { return "translate(0," + (i * 20 + 584) + ")"; });

    legend.append("svg:line")
        .attr("class", String)
        .attr("x2", 8);

    legend.append("svg:text")
        .attr("x", 12)
        .attr("dy", ".31em")
        .text(function(d) { return "Iris " + d; });

    // Add foreground lines.
    foreground = svg.append("svg:g")
        .attr("class", "foreground")
      .selectAll("path")
        .data(flowers)
      .enter().append("svg:path")
        .attr("d", path)
        .attr("class", function(d) { return d.species; });

    // Add a group element for each trait.
    var g = svg.selectAll(".trait")
        .data(traits)
      .enter().append("svg:g")
        .attr("class", "trait")
        .attr("transform", function(d) { return "translate(" + x(d) + ")"; });

    // Add an axis and title.
    g.append("svg:g")
        .attr("class", "axis")
        .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
      .append("svg:text")
        .attr("text-anchor", "middle")
        .attr("y", -9)
        .text(String);

    // Add a brush for each axis.
    g.append("svg:g")
        .attr("class", "brush")
        .each(function(d) { d3.select(this).call(y[d].brush); })
      .selectAll("rect")
        .attr("x", -8)
        .attr("width", 16);
  });

  // Returns the path for a given data point.
  function path(d) {
    return line(traits.map(function(p) { return [x(p), y[p](d[p])]; }));
  }

  // Handles a brush event, toggling the display of foreground lines.
  function brush() {
    var actives = traits.filter(function(p) { return !y[p].brush.empty(); }),
        extents = actives.map(function(p) { return y[p].brush.extent(); });
        
    foreground.classed("multibrush-fade", function(d) {
      return !actives.every(function(p, i) {
        var res = false;
        for(var j = 0; j < extents[i].length; j++) {
          res = res || extents[i][j][0] <= d[p] && d[p] <= extents[i][j][1];
        }
        return res;
      });
    });
  }
}());
    </script>
  </body>
</html>
