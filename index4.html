
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/jqtree.css"/>
    <link type="text/css" rel="stylesheet" href="css/zoomable.circles.css"/>
  </head>
  <body>
    <h2>
      Flare code size<br>
      circle packing
    </h2>
  
    <div class="container">
      <div class="row">
        <div class="span2">
          <div id="tree1"></div>
        </div>
        <div class="span10">
          <div id="circlepack"></div>
        </div>
      </div>
    </div>

    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.3.9/d3.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="js/tree.jquery.js"></script>
    <script type="text/javascript">

var w = 740,
    h = 740,
    r = 720,
    x = d3.scale.linear()
              .range([0, r])
              .domain([0, r]),
    y = d3.scale.linear()
              .range([0, r])
              .domain([0, r]),
    current,
    root,
    depth;

var pack = d3.layout.pack()
    .size([r, r])
    .value(function(d) { return d.size; })

var vis = d3.select("#circlepack").insert("svg:svg", "h2")
    .attr("width", w)
    .attr("height", h)
  .append("svg:g")
    .attr("transform", "translate(" + (w - r) / 2 + "," + (h - r) / 2 + ")");

d3.json("flare.json", function(data) {
  current = root = markUniqueElements(data);

  var nodes = pack.nodes(root);

  vis.selectAll("circle")
      .data(nodes)
    .enter().append("svg:circle")
      .attr("class", function(d) { return d.children ? "parent" : "child"; })
      .attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; })
      .attr("r", function(d) { return d.depth <= current.depth + 1 ? d.r : 0; })
      .on("click", function(selected) {
        if(current == selected && selected.parent != null) {
          selected = selected.parent;
        }
        if(current == selected.parent && selected.parent.children.length == 1) {
          selected = selected.parent;
          while(selected != root && selected != null && selected.children.length == 1) {
            selected = selected.parent;
          }
        }

        zoom(selected);

        var node = findCircle($('#tree1').tree('getTree').children[0], selected.$$uniqueId);
        $('#tree1').tree('selectNode', node);
        d3.event.stopPropagation();
      });

  vis.selectAll("text")
      .data(nodes)
    .enter().append("svg:text")
      .attr("class", function(d) { return d.children ? "parent" : "child"; })
      .attr("x", function(d) { return d.x; })
      .attr("y", function(d) { return d.y; })
      .attr("dy", ".35em")
      .attr("text-anchor", "middle")
      .style("opacity", function(d) { return (d.depth <= current.depth + 1) && d.r > 20 ? 1 : 0; })
      .text(function(d) { return d.label; });


  $('#tree1').tree({
    data: [data]
  }).bind('tree.select', function(e) {
    var circle = findCircle(root, e.node.$$uniqueId);
    zoom(circle);
  });
});
var b = false;
function zoom(d, i) {
  var k = r / d.r / 2, k2 = d == root ? 1 : r / current.r / 2;
  var parents = getParents(d);

  if(getParents(current).indexOf(d) < 0) {
    rerenderCircles(vis, parents, k2);
  } else if(d != current) {
    rerenderCircles(vis, parents, r / current.r / 2);
  }
  
  x.domain([d.x - d.r, d.x + d.r]);
  y.domain([d.y - d.r, d.y + d.r]);
  

  var t = vis.transition()
      .duration(d3.event && d3.event.altKey ? 7500 : 750);

  rerenderCircles(t, parents, k);

  current = d;
}

function rerenderCircles(selection, parents, k) {
  selection.selectAll("circle")
      .attr("cx", function(d) { return x(d.x); })
      .attr("cy", function(d) { return y(d.y); })
      .attr("r", function(d) { return (parents.indexOf(d.parent) >= 0 || d.parent == null) ? k * d.r : 0; });

  selection.selectAll("text")
      .attr("x", function(d) { return x(d.x); })
      .attr("y", function(d) { return y(d.y); })
      .style("opacity", function(d) { return (parents.indexOf(d.parent) >= 0 || d.parent == null) && k * d.r > 20  && d.depth >= current.depth ? 1 : 0; });
}

function getParents(node) {
  var parents = [node], current = node.parent;
  while(current != null) {
    parents.push(current);
    current = current.parent;
  }
  return parents;
}

var uniqueIndex = 0;
function markUniqueElements(data) {
  data.$$uniqueId = uniqueIndex++;
  if(data.children && data.children.length) {
    for(var i = 0; i < data.children.length; i++) {
      markUniqueElements(data.children[i]);
    }
  }
  return data;
}

function findCircle(data, circleId) {
  if(data.$$uniqueId == circleId) {
    return data;
  }

  if(data.children && data.children.length) {
    var res;
    for(var i = 0; i < data.children.length; i++) {
      if((res = findCircle(data.children[i], circleId))) {
        return res;
      }
    }
  }
}

function findTreeNode(data, circleId) {
  if(data.$$uniqueId == circleId) {
    return data;
  }

  if(data.children && data.children.length) {
    var res;
    for(var i = 0; i < data.children.length; i++) {
      if((res = findCircle(data.children[i], circleId))) {
        return res;
      }
    }
  }
}
    </script>
  </body>
</html>
