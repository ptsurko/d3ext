
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <link type="text/css" rel="stylesheet" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/jqtree.css"/>
    <link type="text/css" rel="stylesheet" href="css/zoomable.circles.css"/>
  </head>
  <body>
    <h2>
      Flare code size<br>
      circle packing
    </h2>
  
    <div class="container">
      <div class="row">
        <div class="span2">
          <div id="tree1"></div>
        </div>
        <div class="span10">
          <div id="circlepack"></div>
        </div>
      </div>
    </div>

    <script src="http://cdnjs.cloudflare.com/ajax/libs/d3/3.3.9/d3.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script src="js/tree.jquery.js"></script>
    <script type="text/javascript">

var w = 740,
    h = 740,
    r = 720,
    xScale = d3.scale.linear()
          .range([0, r])
          .domain([0, r]),
    yScale = d3.scale.linear()
          .range([0, r])
          .domain([0, r]),
    node,
    root,
    layers = 3;

var pack = d3.layout.pack()
    .size([r, r])
    .value(function(d) { return d.$$size; })

var vis = d3.select("#circlepack").insert("svg:svg", "h2")
    .attr("width", w)
    .attr("height", h)
  .append("svg:g")
    .attr("transform", "translate(" + (w - r) / 2 + "," + (h - r) / 2 + ")");

d3.json("flare.json", function(data) {

  markUniqueElements(data);

  $('#tree1').tree({
    data: [data]
  });
  
  $('#tree1').bind('tree.select', function(e) {
    var circleToZoom = findCircle(root, e.node.$$uniqueId);
    var parents = markAllHiddenAscendingCirclesAsVisible(circleToZoom);

    if(parents) {
      for(var i = 0; i < parents.length; i++) {
        var pack = d3.layout.pack()
          .size([parents[i].r * 2, parents[i].r * 2])
          .value(function(d) { return d.$$size; })

        showNextLayer(parents[i], pack, parents[i].x - parents[i].r, parents[i].y - parents[i].r);
      }
    }
    zoomToCircle(circleToZoom);
  });
  node = root = prepareData(data);
  
  markLayersAsVisible(root, 1);

  showNextLayer(root, pack, 0, 0);
});

function showNextLayer(currentLayer, pack, offsetX, offsetY) {
  var nodes;
  if(currentLayer.$$layer != 0) {
    nodes = packFromExistingLayer(currentLayer, pack, offsetX, offsetY);
  } else {
    nodes = pack.nodes(currentLayer);
  }

  vis.selectAll("circle")
      .data(nodes, function(d) { return d.$$uniqueId; })
    .enter().append("svg:circle")
      .attr("class", function(d) { return d.hasChildren ? "parent" : "child"; })
      .attr("cx", function(d) { return xScale(d.x); })
      .attr("cy", function(d) { return yScale(d.y); })
      .attr("r", function(d) { return d.r; })
      .on("click", function(d) {
        zoomToCircle(node == d ? root : d);
        d3.event.stopPropagation();
      });

  vis.selectAll("text")
      .data(nodes, function(d) { return d.$$uniqueId; })
    .enter().append("svg:text")
      .attr("class", function(d) { return d.hasChildren ? "parent" : "child"; })
      .attr("x", function(d) { return xScale(d.x); })
      .attr("y", function(d) { return yScale(d.y); })
      .attr("dy", ".35em")
      .attr("text-anchor", "middle")
      .style("opacity", function(d) { return d.r > 20 ? 1 : 0; })
      .text(function(d) { return d.label; });
}

function packFromExistingLayer(currentLayer, pack, offsetX, offsetY) {
  var x = currentLayer.x,
      y = currentLayer.y,
      r = currentLayer.r;

  var nodes = pack.nodes(currentLayer);

  nodes[0].x = x;
  nodes[0].y = y;
  nodes[0].r = r;

  nodes.shift();

  for(var i = 0; i < nodes.length; i++) {
    nodes[i].x += offsetX;
    nodes[i].y += offsetY;
  }

  return nodes;
}

function zoomToCircle(circle) {
  var pack = d3.layout.pack()
    .size([circle.r * 2, circle.r * 2])
    .value(function(d) { return d.$$size; });

  var dataToDelete = hideAllBelow(root, circle.$$layer + 1);

  markLayersAsVisible(circle, 1);
  showNextLayer(circle, pack, circle.x - circle.r, circle.y - circle.r);

  var t = recalculateCircles(circle);

  if(dataToDelete.circles && dataToDelete.labels) {
    t.each('end', function() {
      dataToDelete.circles.each(function() { this.remove(); });
      dataToDelete.labels.each(function() { this.remove(); });
    });
  }

  node = circle;
}

function recalculateCircles(circle) {
  var k = r / circle.r / 2;
  xScale.domain([circle.x - circle.r, circle.x + circle.r]);
  yScale.domain([circle.y - circle.r, circle.y + circle.r]);

  var transition = vis.transition()
        .duration(750)

  transition.selectAll("circle")
      .attr("cx", function(d) { return xScale(d.x); })
      .attr("cy", function(d) { return yScale(d.y); })
      .attr("r", function(d) { return k * d.r; });

  transition.selectAll("text")
      .attr("x", function(d) { return xScale(d.x); })
      .attr("y", function(d) { return yScale(d.y); })
      .style("opacity", function(d) { return k * d.r > 20 ? 1 : 0; });

  return transition;
}

function markLayersAsVisible(circle, layerCount) {
  if(circle) {
    circle.children = circle.$$children;
    if(layerCount - 1 > 0 && circle.children && circle.children.length) {
      for(var i = 0; i < circle.children.length; i++) {
        markLayersAsVisible(circle.children[i], layerCount - 1);
      }
    }
  }
}


function findCircle(data, circleId) {
  if(data.$$uniqueId == circleId) {
    return data;
  }

  if(data.$$children && data.$$children.length) {
    var res;
    for(var i = 0; i < data.$$children.length; i++) {
      if((res = findCircle(data.$$children[i], circleId))) {
        return res;
      }
    }
  }
}

function markAllHiddenAscendingCirclesAsVisible(circle) {
  var circles = [];
  var current = circle.$$parent;

  while(current != null && !current.children) {
    if(current.$$children && current.$$children.length) {
      current.children = current.$$children;
    }
    circles.push(current);
    current = current.$$parent;
  }

  return circles.reverse();
}

function hideAllBelow(data, layerIndex) {
  var layersToHide = [];

  (function traverseAndHide(data, layerIndex) {
    if(data) {
      if(data.children && data.children.length) {
        for(var i = 0; i < data.children.length; i++) {
          traverseAndHide(data.children[i], layerIndex);
        }
      }

      if(data.$$layer > layerIndex && layersToHide.indexOf(data.$$layer) < 0) {
        layersToHide.push(data.$$layer);
      }

      if(data.children && data.$$layer >= layerIndex) {
        delete data.children;
      }
    }
  })(data,layerIndex);

  return {
    circles: vis.selectAll("circle")
      .filter(function(d) { return layersToHide.indexOf(d.$$layer) >= 0; }),
    labels: vis.selectAll("text")
      .filter(function(d) { return layersToHide.indexOf(d.$$layer) >= 0; })
  };
}


var uniqueIndex = 0;
function markUniqueElements(data) {
  data.$$uniqueId = uniqueIndex++;
  if(data.children && data.children.length) {
    for(var i = 0; i < data.children.length; i++) {
      markUniqueElements(data.children[i]);
    }
  }
}

function prepareData(circle, layerIndex, parent) {
  circle.$$layer = layerIndex || 0;
  circle.$$size = circle.size || 0;
  circle.$$parent = parent;
  if(circle.children && circle.children.length) {
    circle.$$children = [];
    for(var i = 0; i < circle.children.length; i++) {
      var dataItem = prepareData(circle.children[i], circle.$$layer + 1, circle);
      circle.$$children.push(dataItem);
      circle.$$size += dataItem.$$size;
    }
  }
  circle.hasChildren = (circle.$$children && !!circle.$$children.length) || false;
  delete circle.children;
  return circle;
}
    </script>
  </body>
</html>
